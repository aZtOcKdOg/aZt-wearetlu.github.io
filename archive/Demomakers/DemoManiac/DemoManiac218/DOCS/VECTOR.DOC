
                         0. SOME WORDS IN ADVANCE

     This is V1.29 of the famous DemoManiac - Supplied by vADIUM/aVT!

This version is a bugfixed version of V1.28. We also added all examples
and docs of V1.28 to release a full & complete version of this cool program.

                          This package includes:

                          - English & German Docs
                          - Vector-Doc for DemoManiac
                          - all Examples/Tutorials

                          ~~~ Vector 100%  ~~~
 [Original 1995-11-09 | Google Translate + aZtOcKdOg Edit v0.21 2024-07-14]

Always faster, always more real and always more complex (yeah!). That is the 
trend in vector graphics. A few years ago (yes, yes, back then) you could 
still impress people with line vectors, but today it has to be shading, 
texture mapping, shadows and other new-fangled stuff. But let's forget the 
introductory nonsense! My computer is just tracing away (yes, yes, I've also 
fallen victim to the addiction) and I can't sleep, so I'm going to write you 
(yes, all of you out there, I mean!) another workshop! This time I want to 
pass on my accumulated knowledge about REAL VECTOR to the man/coder (it's 
not that much, but at least). So first of all: rethink! for everyone who 
still uses the Blitter for vector. Yes, that's right, today I want to 
elevate you to the select (ahem) circle of processor vector experts (silly) 
so that from now on we can look down together on those who still don't have 
a clue....

The 1st DIMENSION
----------------

It's boring (it's starting off well...) because it only contains points and 
therefore can be mastered by (hopefully) everyone! Who writes the fastest 
point-setting routine??

The 2nd DIMENSION
----------------

It's much better! because here we find the MOST, MOST IMPORTANT building 
block of the processor vector: THE LINE (tatatataaa)

With it we can do the following:
		- very fast inconvex (overlapping) vector
		- pencil vector
		- gouraud shading
		- texture mapping
		- wolfenstein
		

So some nice things! And all of this is faster than with the blitter, 
although it is twice as fast at drawing lines (monochrome, without 
interruptions) than the BEST processor routine on a 68020 with 14mhz...



THE LINE
---------

So, let's start at 0: We want to draw a line from X1/Y1 to X2/Y2 so 
we use the formula known from the good(?) old(!) school:

	Y=m*x+b

And we notice that we still can't create a line with that! So we take the
much less popular 'point-in-time form' and rearrange it:
(this is how my FIRST line routine, in Basic, worked)

   y-y1     x2-x1      
  ------ = -------                  | *(x-x1)
   x-x1     y2-y1

            x2-x1
   y-y1  = ------- * (x-x1)         | +y1
            y2-y1 

            x2-x1
      y  = ------- * (x-x1) +y1       
            y2-y1 

And now we have a great formula for drawing great lines! 
Yay! But unfortunately it is not particularly fast (floating point 
multiplication at every point etc...) and it is not particularly 
precise either (because floating point numbers are limited (depending on the 
language)) so that the lines mostly miss the target or 'tear up' and and and 
So in short this approach was a complete WASTE OF TIME!

Well we would all probably still be in this line stone age
(even me! although I had other great ideas...root etc...) if not... Yes, if 
the brilliant Mr Bresenham had not come along! (it didn't really matter 
whether he came or not, the main thing was that he thought about it)

BRESENHAM - every(?) coder has heard this magic word before and knows that
it is something quick, ingenious and short that nobody understands and 
everyone uses....
But what is THE BRESENHAM ALGORITHM? and how does it work? and how did the 
guy come up with such ingenious stuff? and what are these stupid questions 
about?

Well, I'll try to explain it to you, dear reader, (since you've put up with 
me until now)....



Well, good old Bresenham, as astute as mathematicians are, recognized what 
takes so much time with conventional line algorithms:
The complete recalculation of the coordinates for each point and the 
subsequent conversion of the floating point coordinates into 'correct' ones!

What? You could have told him that too? Well, so far everything is still 
quite banal (NOTE: IMPORTANT QUESTION - WHAT TAKES SO MUCH TIME HERE!).
So our Bresie fantasized... it would be really cool if you could calculate 
the next one from one screen coordinate.
(NOTE: LET YOUR THOUGHTS RUN FREE TO FIND OTHER SOLUTIONS - LOTS OF
IMIDENT ONES BUT MAYBE THERE IS ONE GOOD ONE...)

But even clever Bresie didn't get any further with clever thoughts! So he 
did what you should always do when a problem is too big/fails: he split it 
into sub-problems and solved one of them first! 

He said to himself: assuming 
(yes, yes, that's how mathematicians think...) the line I'm supposed to draw 
is definitely in the FIRST OCTANT then... HA!! caught! Again, nobody knows 
where the 1st octant is supposed to be! So once again for everyone: 
				 \ 3|2 /
				4 \ | / 1 	(example:   oct2 :  45°- 90°)
				--------- 	(           oct5 : 180°-225°)
				5 / | \ 8
				 / 6|7 \ 

So let's say someone draws a line in the first octant (not a very simple 
one, so not exactly 0° and not exactly 45°) but just 
a nice line.

			_-¯    <-That's it!

Then he/she/it will probably set the starting point first. From there there 
are now 2 possibilities as to where the next point has to be:

	1. Directly to the right of the 1st point
	2. To the right and above the 1st point

Everything else doesn't work in the 1st Oct! - Please understand!
If the line had a gradient of 1 (45°) then it would be case 2 for every 
point.
If it had a gradient of 0 (0°) then it would always be case 1 (horizontal).
Otherwise the two cases always alternate depending on the gradient.

But how do you decide which of the two possibilities should be used? 
Bresenham uses an error term here! With which he can decide which of the two 
points is closer to the 'real' line. 
The error term is basically the distance from the 'real' to the 'screen' 
line. Mathematically speaking, the error term is the part after 
the decimal point that was separated from the coordinates 
in the 'old' algorithms in order to convert floating point 
coordinates into screen coordinates. (clear?)
A small example:
   with the y=(x2-x1)/(y2-..... algorithm, for example, Y came out at 5.783!
   So we cut off 0.783 and set the point at Y=5.
   The error value for this case would be 0.783! The point was 0.8 wrong!

Well...Bresenham calculates this part after the decimal point, so to speak, 
separately from the coordinates. I don't know the exact error term formula 
either, but we don't have to go that deep to understand it.
He now always takes a step to the right and counts how wrong
his line is becoming. With a gradient of 0, it would never be wrong, but 
with any other gradient, the line would become 'wrong' with each point.
If it is now 'too wrong', he simply takes another step up and subtracts 
something from the error counter again, because the line is now something
that has become more correct...

Bresenham's principle in brief:

	-Initialize an error value counter
	-Set a point
	-Add a value to the error counter
	-If the error has become too large then...
         -Step in the other direction
         -Subtract something from the error value (line is better again)
	-Otherwise, set a point again...


Why you have to minimize the error counter and always add M
and why the 'threshold' is exactly 0.5 depends on what the error term 
actually looked like (slope...maximum 1.....) 
but as I said I don't want to / can't go that deep here.

So all of this in one listing:

	dx=x2-x1
	dy=y2-y1

	m=dy/dx
	error=m

	while x1<x2
	  plot x1,y2
	  if error>0,5 then
	     error=error-1 
	     y1=y1+1 	 'if above threshold then UPRIGHT
	  end if
	  error=error+m
	  x1=x1+1 	 'otherwise just RIGHT
	wend

So that's what it's supposed to be? The great Bresenham algorithm? 
With floating point addition and division? Great! But Bresenham didn't give 
up and resign himself to this point! He did what we (coders) all admire him 
for today (he probably had the idea on the toilet!)
Solution:

He multiplied all the terms that occurred by 2*DX not out of frustration and 
to make the routine even slower! No because... but let's see for ourselves: 


  		     dy               dy*2*dx
	out of	M = ---- now becomes --------- and from that M = 2*DY 
		     dx                 dx*1 

	-Zack- No more floating point numbers! If that wasn't brilliant?! 

But he did even more: He changed the starting value for the error term from 

f=m also. f=2*dy in f=m-dx also 

f=2*dy-dx 	(so he changed it by DX!) 

Why? Well, because then the threshold value changes from 0.5 to 0!!! 
Now 1 no longer has to be subtracted if the threshold is exceeded 
(error=error-1) but 2*dx has to be subtracted! 
But that is also logical: before: -1     (0.5*2 = 1) 
			  now: -2*dx  (changed by dx*2 = 2*dx) 

To create a little more clarity (yes, even more!) here is a new listing:

	dx=x2-x1 
	dy=y2-y1 
	
	ddx=dx*2 
	ddy=dy*2 

	error=ddy-dx 

	for I=0 to dx 
	  plot x1,y1 
          if error>0 then 
             error=error-ddx 
             y1=y1+1 
          end 
          error=error+ddy 
          x1=x1+1 
        next i

That looks much better! We only used INTEGER values
and compared with 0!
But the solution is still for a mathematical coordinate system and here too
only for the 1st octant!
You can imagine what it looks like for octants 1,4,5,8
(reflection on x and/or y axis)
Here you insert for y1=y1+1 <=> y1=y1-1 and/or for x1=x1+1 <=> x1=x1-1

For the other octants 2,3,6,7, however, you only have to swap X and Y
. (and their deltas etc.)

Here is a 'finished' BRESENHAM LINE ALGORITHM for all octants and
for the computer coordinate system:


	px=1 
	py=1 
	dx=x2-x1 
	dy=y2-y1 

	if dx<0 then dx=-dx:px=-1 'reflection on x
	if dy<0 then dy=-dy:py=-1 'reflection on y
	
	ddx=dx*2
	ddy=dy*2

if dx>dy then 'octant 1/4/5/8
fehler=ddy-dx

for i=0 to dx
plot x1,y1
if fehler>0 then
y1=y1+py
fehler=fehler-ddx

end
fehler=fehler+ddy

x1=x1+px

next i
exit
else 'oktant 2/3/6/7
fehler=ddx-dy
for i=0 to dy
plot x1,y1
if fehler>0 then
x1=x1+px
fehler=fehler-ddy
end
fehler=fehler+ddx
y1=y1+py
next i
end

This routine can be implemented in assembler!

As you will surely notice, this stuff already needs a whole lot of registers, actually (in my first try) all of them! and that is BAD!
But there is a solution for this too! And so that I don't have to wait
until you figure it out yourself, I'd rather tell you straight away:

Let's remember again which 8 possibilities there are for a line
(octants):

3 2

4 1

+

5 8

6 7

Now you might think that a line that goes from + to 3 (i.e. in the 3rd octant) looks exactly the same as one that goes from + to 7 (i.e. in the 7th octant) and that's right because to bring a line from the 3rd to the 7th octant it is enough to swap the start and end coordinates.

(the same applies to 4/8 5/1 etc...)

So you could save either the octants 5/6/7/8 or the octants
3/4/5/6 if you 'flip' the line if necessary, and in doing so you save
either PY or PX depending on in which case (X or Y mirroring)
the line should be 'flip'd.
To always get lines in the octants 2/1/8/7 (always increasing x-coordinates)
you would simply have to write:

cmp.w d0,d2 ; compare x1 and x2
bge.s .ok ;x2 >= x1 ? yes then
exg d0,d2 ; swap x1 and x2
exg d1,d3 ; swap y1 and y2
.ok:

I'll explain to you later why this case in particular can be very useful. But it doesn't hurt to think for yourself - so why could it be good when setting points if you only have to go one bit to the right (and maybe up).

But first of all, let's look at another optimization option (there aren't many left): once again a short overview in Basic:

.
.
Plot...
If error=0 .... -A
y+...
error-...
end...
error+.... -B
x+...
.
.
The comparison (A), a TST in assembler, can be omitted if... can you guess?..... if you change the routine like this:

Plot...
error+.... -B
if error=0 .... -A
y+....
error-...
.
.

Correct! Just do the error addition (B) a little earlier! That 
doesn't do any harm, since the addition would have to be carried out anyway...
Because now in assembler it says something like this...

ADD.W Dx,Dy
TST.W Dy
BLE.s ..... ;<=0 ?

But : NOTE : After a write access to a data register, the
flags are set as if you had done a CMP.x #0,Dy afterwards.!!
So the TST is superfluous in this case and only the following remains:
ADD.W Dx,Dy
BLE.s .... ;<=0 ?

And we've already saved a command! What do you think? Not much?
On the one hand, you are right, a TST takes just as much time as a NOP, namely
4 cycles, but for a line across a Lores screen that is:
(a raster line has 228 cycles)

(320*4)/228 = 5.6 RASTER LINES!!

So this ridiculous TST gives us ONE FRAME for just 45 long lines!!!!
NOTE: THE IMPORTANCE OF A COMMAND INCREASES LINEARLY WITH THE NUMBER OF RUNS
That is why plotting routines that previously save all registers are ABSOLUTELY DEADLY when drawing lines!

But I suspect that was already clear to you...

The BRESENHAM ROUTINE that is now available to us is already very good
and can only be optimized for a special case, so keep it safe! because instead of setting points, there will be many other nice
things.....

Nevertheless, I would like to briefly show here again how you can draw simple processor lines the FASTEST way.

The 68000 users have to work much harder here than the '68020 or higher' coders. But it can also be interesting for them (68020'ers):

So first a normal 68000 point setting routine

;d0/d1 - position
;A4 - mulutab
;A6 - screenpointer

move.w d0,d2 ;save xpos
lsr.w #3,d2 ;xhardpos (x/8)
add.w d1,d1 ;for mulutab
add.w (a4,d1.w),d2 ;(x/8)+(y*40)=offset
not.b d0
bset d0,(a6,d2.w) ;set the dot !

There is no faster way to set any point on an
A500?! I don't know of any anyway! The only disadvantage is that
3 registers are messed up and they all need to be saved....
Plus there are far too many commands that have to be executed for each point! (see TST calculation)

So if we use the trick shown above to only have to set the
bit to the right of the last one (only octants 2/1/8/7) i.e.
at every point x+1 then that gives us lots of new ideas....
For example, you could create a list that contains all the bits and at every point
get the next pattern from the list and then or it into the plane:
or.b (a0)+ or something like that..
But it is even quicker and even cleverer with the following trick:
(By the way, this is not mine! but still great!)

Let's assume we could set the point as follows:

BSET d0,(a6)

And d0 would be at 7, i.e. in the current byte on the very left (8th bit) then
we would now only need a

SUBQ #1,d0

To get one pixel to the right (7th bit)! Great! But unfortunately 
that only works until D0 is at 0 (1st bit) after that D0=-1 would be the result and that would be CRAP! 
But in this case you would just have to set D0 back to 7 and go one byte to the right, which would be done in no time at all with: 

MOVEQ #7,d0

ADDQ.L #1,a6

And whether D0 has become negative is also very easy to determine (BMI.s x) so actually it should be possible....

So let's make a first sketch in assembler! Let's say we have determined the
start bit and stored it in D4 and the start byte in A0
We also have: ¯¯ ¯¯

Error -D0
ddx -D1
ddy -D2
i -D5 (counter for length of line)

Then we could write (for the first octant):

bra.s .loop
.loop1: ;Loop with jump to the next byte

moveq #7,d4 
addq.l #1,a0
.loop: ;Normal loop
bset d4,(a0) ;set point

add.w d1,d0 ;error=error+ddx

ble.s .NoUP ;error<=0 ? yes then
sub.w d2,d0 ;error=error-ddy
lea -40(a0),a0 ;one line up
.NoUP:
subq.w #1,d4 ;one bit to the right

So for now up to here, because now follows a step that at first glance is hard to swallow! But I'll show it to you first... please don't despair immediately....

dbmi d5,.loop ;normal
dbpl d5,.loop1 ;if negative flag set
rts

Yes yes, anyone who has only known Dbra from DBcc will be amazed! but what does this crazy command combination do?

Now the DBMI command tests 2 things at the same time: whether an overflow into the next byte has occurred (d4 negative) and whether the line is already over (d5=$ffff)! If the [subq.w #1,d4] has set the N-bit (negative) the DBMI command is skipped! But one is not subtracted from D5 as is normally the case with the DBcc run. Therefore we would have a problem if an overflow and the end of the line occurred at the same time. But let's follow the case mentioned above further: The N-bit is set and D5 is not yet 0 The DBMI command is therefore skipped! The DBPL, however, would only be skipped if the N-bit is not set - so it is executed! and then checks whether D5 is already 0! if it is not, it is decremented by 1
and it jumps to loop1, where the next byte is addressed and
then it goes (without a jump!) into the normal loop.

You can explain all other cases yourself! (You should!) But
it always works!
Ingenious, isn't it? You really can't draw lines faster on a 68000!
Or can you? Who knows, maybe a new Bresenham will come along and show us
how stupid we all were.....





Hello, the next beautiful day is over and I thought, since I'm already too tired to code, I'll
continue writing my work, so then... (1:06 a.m. - I just saw Al.Mundy on VOX)




OK, now it's time for the Bresenham final sprint! I'm going to introduce you to a Bresenham routine that's been optimized using all the tricks I know. This time it's even in assembler, so you can really cut it out and enjoy it. But first I want to reveal one last trick to you: With the help of another small change in the terms (I don't feel like explaining them in detail now) you can save yourself a few more commands. So here again in Basic for the first octant to help you understand:

dx=x2-x1

dy=y2-y1

e=-dx/2

for i=0 to dx

plot x1,y1

e=e+dy

if e>0 then

e=e-dx

y=y+1

end

x=x+1

next

As the expert eye can see, the deltas (dx & dy) no longer have to be

multiplied by two! The calculation of e is now a little

different, but who cares....

But now in assembler:

***************************************************************************

LINE: ;bresenhamgrundstock d0/d1-d2/d3

cmp.w d1,d3 ;y1<y2 ?

bge.s .ok

exg d0,d2 ;always y1<y2 ! not ideal for setting points
exg d1,d3 ;but for other things....
.ok:

;calculate a0 here from d1 ;varies depending on the application.....

moveq #1,d7 ;px (direction for x)

sub.w d1,d3 ;dy=y2-y1 [d3=dy]
sub.w d0,d2 ;dx=x2-x1 [d2=dx]
bpl.s .ok2 ;dx positive ?
neg.w d2 ;|dx|
moveq #-1,d7 ;px (direction for x)
.ok2:
move.w d2,d4
lsr.w #1,d4 ;e=dx/2
neg.w d4 ;e=-dx/2 [d4=e]

cmp.w d2,d3 ;dx>dy ?
bgt.s .okt2
move.w d2,d1 ;i=dx [d1=i]

.loop1:
;Do something; xpos=d0 ypos=a0 ;plot or calc or ......

add.w d3,d4 ;e=e+dy
ble.s .2
addq.l #....,a0 ;y=y+1
sub.w d2,d4 ;e=e-dx
.2: add.w d7,d0 ;x=x+1 or x=x-1 depending on d7
dbra d1,.loop1
rts
.okt2:
move.w d3,d1 ;i=dy [d1=i]
.loop2:
;Do something; xpos=d0 ypos=a0 ;plot or calc or ......

addq.l #....,a0 ;y=y+1
add.w d2,d4 ;e=e+dx
ble.s .3
sub.w d3,d4 ;e=e-dy
add.w d7,d0 ;x=x+1 or x=x-1 depending on d7
.3: dbra d1,.loop2
rts
**************************************************************************


So there you have a Bresenham line calculation routine that has been optimized to the best of my knowledge! I will build on it throughout the rest of the course! So understand it or leave it alone, I have done my best (it wasn't much, I know) to explain to you how the Bresenham came about and the many(?) little tricks. The 3rd DIMENSION---------------- Yes, now it's getting exciting (crackling) you've already learned a little about 'the world of the real vector' but now it's really going to happen! There is so much to say about -3D- that I have to assume a few things or leave them to other workshops so that this workshop doesn't become (even) more endless: - YOU won't lose your hair from shock when you hear the word vector! - YOU can rotate 3 points around all 3 axes in less than 3 frames
(see HowToCode7.0 for how matrix rotation works)
- YOU could possibly imagine that it would be possible to use the processor instead of
wild blitter orgies.
(Blitter: stupid & fast)
(Processor: clever & only fast with the right principle)

Everything OK? (HA! That gives me an idea - Everything in Vector?

Wouldn't that be a great motto for us Vector fans?????)

PENCIL-VECTOR
---------------------

Well... listen carefully, my son... the high priest will now initiate you into the secrets of... (gong, flash of light) PENCIL (smoke)...
Well (why do I always start with 'now'? That's not style, so let's say it again):
Pencil has two major advantages: It is complex and slow.
Ha, everyone laughed? Well, then not! But now for the serious part:

Pencil is relatively easy to code and looks quite nice. And it is
not as 'hackneyed' as the good old blue BlitterCube.
But how does Pencil actually work?

Pencil is based on the following principle: 

-You build each area line by line.

-Each line is filled with a color gradient from light to dark

(or the other way around) depending on its length.

This means that a gradient can be seen across the entire area later.

Since the line lengths are constantly changing, a nice pattern is created:

-pencil vector, exactly-, which can even remind you of a pencil drawing

(well! says the art student).

Now for the implementation: So the color gradients are of course stored! One for

each possible width (0-319) that works in a small IFF picture

320x320 pixel size. These then only need to be blitted to the right position and voila,
there is a wonderful pencil vector...

This brings us to a very moving problem: For each line of an area, we need to know its width and the X position of the first pixel in order to be able to blit the corresponding gradient to the right place!

Or to put it another way:
For each line of an area, an X start and an X end coordinate are required.

This is the first problem of the processor vector! If you manage to
solve it, then you've already got the rest in the bag!

So good luck, I'm going to take a nap now. (1:54 a.m.)

............................ THINK BREAK ...................................




Hello and let's continue (9:11:93 23:59) with the ULTIMATE WORKSHOP!

By the way, my 100 image animation is now finished...

RAYTRACING RULES!

I hope you have now thought about the first and perhaps most important problem with Processorvector!

But I still want to try to explain everything.

So first we will only look at 1 surface and for the sake of simplicity a triangle (NOTE: SIMPLIFY/DIVIDE THE PROBLEM) we now need 2 pieces of information for each line of the surface (Xstart and Xstop).

In order to manage these we first need a memory block that has 2 words ready for each line (i.e. 256*4 bytes).

The basic idea is now very simple: To get the Xstart/stop values ​​we use a simple line algorithm, only instead of setting points we save the current X value for each line. If there is only one line from 0/0 to 6/6, this would be in our buffer (if we always save as XStart). BUFFER: 0.0 ;Line 1 * 1.0 ;Line 2 * 2.0 ;Line 3 * 3.0 ;Line 4 * <-The line! 4.0 ;Line 5 * 5.0 ;Line 6 * 6.0 ;Line 7 * In each line, the Xposition had increased by one. So far, that's not a problem. But the difficulty now lies in determining whether the Xcoordinates are Xstart or Xstop values! One way to make this decision is this:
If the Xstart value of a line has already been written, then another value in this line is to be considered as Xstop, since only 2 points are possible in a line per area (triangle/square and regular polygon).

This procedure requires that the table has been initialized, e.g. with -1, and that a check can be carried out at each point. This is not a technical problem, but it takes up grid time.....
Nevertheless, my first pencil routines were based on this principle.

Another way to make the Xstart/Xstop decision is this
[which I got from Arne B. (really brilliant!)]:

He found that a whole line always only provides either Xstart or only Xstop values, so the comparison at each point can be omitted. But what is even more ingenious: He discovered that if you divide the lines into two groups, namely (A) those running from bottom to top and (B) those running from top to bottom, you simply have to switch between Xstart and Xstop when you change from A to B (or B to A). So again slowly: -The first line is always Xstart. Its 'type' (A or B) is saved and the column (Xstart/Xstop) in which it was noted (here always Xstart) is also saved. -If the next line is of the same type, it is noted in the same column (Xstart/Xstop). -If it is of a different type, the other column is used. Using this principle, you get a complete list of Xstart/Xstop values ​​for any convex (2 points per row) surface. Now you just have to remember to save the minimum and maximum Y position of the surface so that you don't have to process the entire buffer later. If you keep this in mind, you don't need to clear the buffer again, etc. So that should be enough for today, I'm really too tired now...0:34 Ha! Many weeks have passed and I've had enough sleep again. Now that you know the principle of the pencil vector (buffer, Xstart, Xstop...) we can slowly move on...


PROCESSOR VECTOR
-----------------------

Processor Vector differs from 'outdated' Blittervector only in that the surfaces are drawn with the... yes, with the processor.

But why with the processor? When the blitter provides such brilliant functions for

Vector?

Well, on an A500 with 68000 (for which the blitter was actually developed) Blittervector is still the best and fastest (the best

blittervector coder is undisputedly TaiPan/Complex).

But if you make inconvex (overlapping surface) objects, and you should always do that because they are much nicer, the blitter suddenly

becomes unbelievably slow (drawing in buffer, copying it and deleting it...).

If you have a fast 32-bit processor (from 68020), which is the case in all Amigas still sold, and possibly real 32-bit FAST RAM, then the processor is a factor faster than the good old blitter. With the blitter vector, you always first draw the border lines and then fill them. This of course also works with the processor, but it is EXTREMELY slow. But if you know how Pencil works, you can quickly figure out how to draw areas (without dots and filling). First you calculate a table with Xstart and Xstop values ​​for each line of the area and instead of blitting these lines under each other (like with the Pencil), you MOVE them into memory with the processor. This has the huge advantage that no buffer is required because
the underlying areas are automatically overwritten. In addition,
each point of an area is now only drawn ONCE - with the
blitter, the edge points were drawn TWICE (once when drawing lines
and once when filling).

The most important routine in the processor vector is the one that fills a line
from Xstart to Xstop with a color. Here it is again painfully noticeable that the Amiga does not yet have a
ChunkyPixel mode (1byte=1pixel) because in our planar system (1bit=1pixel) the normal assembler commands slow down the work enormously. (We have to access the memory 8 times for 256 colors - the
Chunky people only once!!!)

Although Processorvector is not really worth it on a 68000, let's first think about what the FillLine routine should look like here.

The task is clear: draw a horizontal line (----)

from pixel A to pixel B

You could of course run a loop to do this, which plots all the individual points. But if you consider that the FillLine routine is run through up to 600 times with just a single throw, you should look for a somewhat faster solution...

search...search...search...

So if the line always started at positions divisible by 16

and always had a length divisible by 16, you could copy it into memory with

move.w #-1,(a0)+

To be a little more specific, let's start with an example: a 64 pixel long line from pixel 0.

move.w #-1,(a0)+

move.w #-1,(a0)+

move.w #-1,(a0)+

And now something a little more difficult: a 73 pixel long line from 0 (73=64+9).

move.w #-1,(a0)+
move.w #-1,(a0)+
move.w #-1,(a0)+
move.w #-1,(a0)+
or.w #%1111111110000000,(a0)+

What did we do? Well, it's very simple: the 64 pixels were drawn very quickly and the 9 extra pixels were simply added on at the end.

This had to be done with OR because a move would have deleted the last 7 bits behind the line (7 zero bits at the end), which was not wanted.

And now it's really complicated: a 73 pixel long line from 12.

or.w #%00000000000011111,(a0)+
move.w #-1,(a0)+
move.w #-1,(a0)+
move.w #-1,(a0)+
or.w #%11110000000000000,(a0)+

The expert eye will of course have immediately recognized that we have now also set some bits ‘by hand’ at the beginning in order to get from 12 to the next position divisible by 16.

The next position divisible by 16 after 12 is ---- yes, bravo! 16!.

So the first 4 bits (from 12 to 16) have to be set using or.

After that we can carry on again at mega speed (16 pixels per command). Until we have 69 pixels (5+4*16) because another word would be too much of a good thing (we only want 73 pixels) so we set the rest (73-69=4) again 'by hand'.

From these examples you have (hopefully) recognized the following principle:
For lines that are longer than 16 pixels ....

First you set the bits that are necessary to get to a position that is divisible by 16 (an OR.W), then you write blocks of 16 (Move.w) until (length-starting pixel)/16 pixels have been set and finally you add a few more bits (if any are still missing) at the end (an OR.w).

The two OR steps can of course sometimes be omitted - namely if the line is already in a position of 16 or has a length that is divisible by 16 anyway.

With this principle you have a 16-bit line fill routine. 16-bit because you always write a word (the fastest on a 68000).

If you were to use the plot-in-a-loop method described above, you would have a 1-bit linefill routine (sounds much slower, doesn't it?). On a 68020 you would use a 32-bit routine (it's not a 32-bit processor for nothing), i.e. one that only works with long words, but trying to do this on a 68000 is pointless, since a long word is written to memory exactly twice as slowly as two words - so the whole thing has no advantage (on a 68000). But before we get into practice, we need to think a little further, because our principle still has one limitation: only lines that are longer than 16 pixels can be processed. In order to allow smaller lines, there are basically two options: 1. You write an extra routine that is specialized for small lines. In this case, however, you have to check for each line whether it is small or

large (<16? >16?).

2. You change the algorithm a little (I'll show you how in a moment) to allow for

small lines right down to individual points.

In this case, however, a little too much work is done with small lines.

The second option is to always move one more block of 16 than is actually necessary (easy, since DBRA always does one run too many anyway) and then delete the pixels that have been drawn too many using AND.

So to draw two pixels at position 7:

or.w #%00000011111111111,(a0)+ ;next position of 16

;no blocks of 16 (negative number)

and.w #%0000001100000000,-2(a0) ;end correction.

This method requires a more complicated calculation and you would also have to copy the old content back in after deleting... This is common but it is slower and more complicated than writing your own routine for mini lines (<16). So back to the first option... A routine for lines up to 16 pixels long could look like this: d0 - first pix d1 - length ShortLine: moveq #-1,d2 ;set all bits lsr.l d1,d2 ;delete 'length' bits (zero bits are inserted on the very left) not.l d2 ;only set 'length' bits move.w d0,d1 ;save and.w #$f,d0 lsr.l d0,d2 ;shift to the correct position. lsr.w #4,d1 ;Calculate target offset

add.w d1,d1 

or.l d2,(a6,d1.w) ;Draw line

rts

This routine calculates the required bit pattern at the beginning by first
setting all bits (moveq #-1)

%11111111111111111 11111111111111111

Then shift the whole thing to the right by 'length' (e.g. by 6) :

%0000001111111111 11111111111111111

This creates 'length' zero bits, which are now inverted by a not.l:

%1111110000000000 00000000000000000

And now we have a longword in which the 'length' bits are set at the beginning.
This is now just shifted to the correct position
(e.g. for pos 13):

%0000000000000111 1110000000000000

And the resulting pattern can now be OR'ed easily...

This solution may not be the fastest but it is faster than
a routine in which all widths at all positions (1KB of precalc data)
are already precalculated and only need to be read out!

Why? Well, because complicated 'memory commands' are needed to read them
e.g.: move.w (a0,d1.w),(a1,d2.w) and similar...
In addition, offsets have to be calculated or read from tables, so
the whole thing degenerates into a wild movement.
While our solution only works with 'small' commands, it is, so to speak,
easier to digest, faster, more optimized, shorter and harder to write...
But exactly this style, namely the one with lots of small ADDs, NOTs, LSxs
that all only operate with data registers, is the style of the future!

A routine programmed with it is 4 times faster on a 68020 than
on a 68000, while a table move orgy is only 1.8 times faster.
(All information is, as always, without objection.)
And for the dreamers who already see themselves coding on RISCs, the advantage is
even greater because, as we know, there is no more move there...
(To copy a value from a to b in memory, at least 2 commands are
required and with move.w (a0)+,4(a1,d3.w*4) it is 9 commands!!!)

To give you the necessary tools for the right path - 
here are a few short tips on bit-fiddling commands:

OR - just as fast as Add. Only changes bits set in the source.

Everything that is set in the source is also set in the destination.

AND - Only leaves the bits in the target that are 1 in the source.
An and.w #15,dx means that dx is always between 0 and 15.
it enables wonderful clipping!! (-2 => 13) REMEMBER!!!
(this trick only works with 1,3,7,15,31,63,127,255....)

EOR - inverts the bits that are set in the source.
an Eor.w #15,dx works like an x=15-x! REMEMBER!!!

NOT - inverts all bits in the target! Don't confuse with NEG !!!!!

NEG - works like 1-(x+1) - So negates the target! Does NOT just change
the highest bit, although that is the only bit that counts as a sign bit!

LSx - Everyone knows this. ALWAYS adds zero bits.
The bit that was last shifted out to the left or right ends up in the X-flag. ASx - With negative numbers, it may also shift 1 bit forward with the correct sign. (slower than the LSx commands) ASx also loads shifted out bits into the X-flag. ADD - Don't worry, I don't think you're so stupid that you don't understand ADD, but I just wanted to mention that the X-flag is set in the event of an overflow ($ffffffff+$1=0)!! ADDX - Performs a completely normal addition AND then adds 1 if the X-flag was set (this is deleted in the process). EXT.L - Expands a register to a longword. If the lower word is positive, the upper word is deleted! If it is negative, the upper word is filled with $ffff. Sometimes you can use this command
cleverly to delete the upper word without swapping.

EXT.w - Like Ext.l, but everything is done a little smaller:
If the lower byte is positive, the upper byte is deleted and otherwise
filled with $ff. The Hiword is ignored in this command.
So to extend a byte to a longword, the following is necessary:
ext.w d0
ext.l d0
On the >=68020 processors, there is the command
extb.l d0 for this combination


If you only use data registers, each of these commands is equally fast.
And requires exactly 1 word in memory.
If possible, two of them should always be in a row before the
next 'complex' command comes, so that it is at a longword address
(only with 680x0 x>1).

Another little trick on the side: If you want to get the remainder of an integer division
by a power of two X, you can write:
DIVU #x,d0
CLR.W d0
SWAP d0
But it is much faster with:
AND.W #x-1,d0

At the moment you might still be thinking when do I need such crap... but I
have only explained the commands and tricks that I will urgently need later...

Okay then! Before we finish the PROCESSOR-VECTOR chapter, we will
put together a proper 16-bit fill-line routine that is optimized for 68000 (you should make the 68020 version yourself!!!).

OPTIMIZING THROUGH LONGWORD BOUNDARIES, CACHING and LOOPS
-------------------------------------------------------

To write an optimized routine, here is something about how certain
processors like their code best...

68000: Precalculate as much as possible (as long as the bit-frieming route is not faster). Use pipelining of the copros (blitter, proc, blitter, proc...).
Jump as little and as short as possible! No Dbra loops for time-critical

routines - it's better to copy the code x-times in a row...

For many individual cases, create your own routines from the program

or modify them (self-modification)...

But all of that is old news, old news, old news,

68010: Only improvement: 3word loops such as:

.loop: move.w (a0)+,(a1)+

dbra d0,.loop

Are recognized and greatly accelerated! Otherwise everything has stayed the same

(apart from MMU support for the 010)...

Anyone who voluntarily has a 68010 installed should be punished!

68020: Brilliant innovations! Real 32 bits!!! That means longwords are not

treated more slowly than words! Very useful commands for working with tables (a0,d0.w*2) takes NO more time than (a0,d0.w)! New commands for fiddling with bits (BitFields). Improved architecture (is faster at the same clock frequency). WaitState handling: If wait cycles have to be inserted before a write access to the chip memory, the next command is processed here as long as it does not depend on the result of the last one. Commands that are located at longword addresses (divisible by 4) are executed TWICE(!) as fast. Instruction cache (enough to significantly speed up even more complicated loops) FPU support. An FPU can be addressed directly (on a 68000 an emulation was inserted). Dbra loops should be used on this processor. Blitter should be largely dispensed with. Attention should be paid to cache optimization. The Fastmem can be used without any problems, whereas the Chipmem should only be touched with a pair of pliers. Fill the 256 cache! (It's not particularly difficult..) 68030: Only hardware optimizations. Now also data cache! and larger instruction cache. Actually a 'nicer' (faster) version of the 68020. A 50mhz 68030 with 50mhz 68882 is still the fastest there is on the Amiga. (if the rumor about the 80mhz 68040 is not true) The Fastmem is sometimes slower here, but this should be compensated for by the data cache?! Lots of 'small' commands with few memory accesses is the motto here 68040: Awesome architecture! The caching system has been greatly expanded and improved(?) but it requires a precise knowledge of the many cache modes if you want to code successfully here... An FPU has been integrated directly, which is even faster than the 68882. The 68040 is brilliant for ray tracing! but requires a very precise study of the processor architecture and a good knowledge of the memory components (burst?, wait states?, access time?...). The 68040 is only slightly faster at accessing the CHIPram than I am at typing the number into a calculator... Since the Fastmem is usually not delivered as 72ns RAM, all we can say here is: keep your hands off the RAM and use the cache! PS: NO RISC NO FUN!


So you have to decide which processor you are programming for...
Although the actual decision is only between
68000,68010 and 68020,68030,68030.
But we want to use the good(?) old(!) 68000 again here.....

SO LET'S GO:

The routine should draw a horizontal line from pixel A to pixel B.

So we are given two X positions and a register that shows us
the start of the right line...

Fillline: ;d0-pos1 d1-pos2
;a6-linestart (ypos)

cmp.w d0,d1

bge.s .ok

exg d0,d1
.ok: sub.w d0,d1 ;d0-start d1-length

That was quite easy, first make the start and length from the coordinates.

cmp.w #16,d1
ble ShortLine

We jump out here straight away if it is a 'small' line.

Now we have to determine the word in which our line starts...

move.w d0,d2 ;save start
lsr.w #4,d0 ;start/16 (which word)
add.w d0,d0 ;start*2 (convert to bytes again)
lea (a6,d0.w),a0 ;START ADR

The next question that torments us is: at which pixel within this

word does our line start exactly? So...

and.w #$f,d2 ;rest of Start/16

If the result were 6, for example, we would know that in order to fill up to the next word boundary, we would have to or %000000111111111. (FOLLOW UP!)
If the result was 15, %0000000000000001 would be in the current word and at
0 it would be equal to %1111111111111111..
Values ​​below 0 and above 15 are of course no longer possible after the AND #$F.
One way to create the pattern would be:
moveq #-1,dx
lsr.w d2,dx
Another way would be to read from a table:
add.w d2,d2
move.w .bits(pc,d2.w),d0 ;The table must not be far away
(integrate into code)!
The table would look like this in this case:
.Bits: dc.w %1111111111111111 
dc.w %01111111111111111 
dc.w %001111111111111111 
dc.w %000111111111111111 
dc.w %00001111111111111 
dc.w %00000111111111111 
dc.w %00000011111111111
dc.w %00000001111111111
dc.w %00000001111111111
dc.w %0000000111111111
dc.w %0000000001111111
dc.w %0000000000111111
dc.w %0000000000011111
dc.w %0000000000001111
dc.w %00000000000001111
dc.w %00000000000000111
dc.w %00000000000000111
dc.w %00000000000000011
dc.w %00000000000000011
dc.w %0000000000000001
Almost everyone works with a SHIFT TABLE like this but I don't know if
the BIT-Friemel solution isn't faster?! But since this is a 68000
the pre-calculation is probably faster.

So we have the right pattern to get to the next word position
in D0! So what are we waiting for? in with it...

or.w d0,(a0)+ ;Write Begin bytes

But now the question is: how many bits have I already set with it?

because this value must now be subtracted from the length!

Well the formula for this would be quite simple: 16 - PosInWord = PixDone!
But how do we find out....

..Yes, that's right, we use a trick from the bit-fiddlers: EOR.W #$f,D2
(if you don't understand that, then you weren't paying attention a little further up!) Try it out on a piece of paper in an emergency: If you invert the lower 4 bits ($f=%1111) of a
number between 0 and 15, you get y=15-x... amazing...

There's just one catch: (I'm assuming we're using the table method) we multiplied PosInWord by 2 to get the offset to the table. Another reason to do without the table?? but
you are responsible for optimizations...
So since saving the register beforehand and retrieving it afterwards requires 2 commands, dividing by two is probably the fastest...

lsr.w #1,d2
eor.w #$f,d2 ;how many bits done ?

We now subtract this number from the length...

sub.w d2,d1
beq .done

and disappear immediately if that was all (length=0). If not, we now have to calculate how many words we can fill before the end of the line is reached (remaining length/16).

move.w d1,d2 ;copy length
lsr.w #4,d2 ;how many words can we fill ?
beq .rest
moveq #-1,d3 ;fill pattern

If there is already a whole word too much (remaining length/16=0) then we jump straight into the part that adds the last bits 'by hand'. If not, then comes the TURBO-FILL part of the routine! The pattern could also be described outside of the routine to save a few more cycles... But before we go any further, here's another trick: Normally, a DBRA loop would follow that presses the words into the memory. But that means that the Dbra command has to be executed once after every move! This is no problem on a 68020 
Tragic because Move&Dbra are already in the cache on the second run and
even a 68010 could recognize the loop (on a 1 plane) but a
68000 just gets slower...

That's why we use a special trick here:
(found in Trexx-Warrior) 
We consider that the loop can be run through a maximum of 20 times
(320/16=20) and store the following code accordingly:

.fill: move.w d3,(a0)+ ;20 times...

move.w d3,(a0)+

move.w d3,(a0)+

move.w d3,(a0)+

move.w d3,(a0)+

.
.
.
And if we now need 20 moves, we simply jump to .fill! But if we only need 19 moves, we jump to .fill+2!
for 18 moves, we jump to .fill+4 and so on....
So far so good, but to calculate the offset, we would need y=20-x
and that does NOT work with eor.w #20,dx! (20 is not a power of 2-1)
You could simply create 31 moves and then calculate the offset using EOR.W #31,dx!
but it saves more space to put the cart before the ox or to put the cart before the horse...
What I mean is to simply put the label '.fill:' behind the last move
because then you can jump to .fill with 0 moves. with 1 move to .fill-2
with 15 moves to .fill-(15*2)...
The offset can be easily calculated using y=-x*2...

add.w d2,d2
neg.w d2
jmp .fill(pc,d2.w) ;instead of dbra !

3 commands at the beginning instead of a Dbra after each move...
This technique can also help a 68020 to be even faster under certain circumstances
as 20 moves still fit easily into the cache! But with 8 planes
a Dbra would definitely be faster...

With this turbo fill (16 pixels for EVERY command!!!) we have the FASTEST POSSIBLE 16-bit fill loop there is! because 16 bits are really filled with every command...
After this turbo loop, there is now some calculation to set the remaining bits:

.rest:
and.w #$f,d1 ;rest bits...
beq.s .done

From the length we now calculate the part that no longer fits into a word and if there is no such part (length/divisible by 16) it goes out immediately..
To set the remaining bits we now use a table again..

add.w d1,d1
move.w bits2(pc,d1.w),d0
or.w d0,(a0)
.done:
rts

Not particularly complicated, is it? The table here must be exactly
inverted compared to the first shift table:

Bits2: dc.w %000000000000000
dc.w %1000000000000000
dc.w %1100000000000000
dc.w %11110000000000000
dc.w %11111000000000000
dc.w %1111100000000000
dc.w %1111110000000000
dc.w %1111111000000000
dc.w %1111111100000000
dc.w %1111111111000000
dc.w %11111111111100000
dc.w %11111111111110000
dc.w %111111111111110000
dc.w %111111111111111000
dc.w %11111111111111100
dc.w %111111111111111100
dc.w %11111111111111110

Please do not forget (to speed things up) to set a CNOP 0.4 after each table so that the following code is again at an address that is divisible by 4! The tables must be in the middle of the code because they must not be more than 256 from (pc,xx)! And they have to be addressed via PC because otherwise we don't have enough address registers free to carry out the turbo fill with 3/4/5 bit planes! But there's still one part missing! The ShortLine algorithm! I've already presented one above, but here's a better one that's more suitable for this (tested) routine: ShortLine: ;do-firstpix d1-length moveq #1,d2 ror.l d2,d2 asr.l d1,d2 Well? Did you understand how the bit pattern was created here? The goal was clear: D1 bits should be set at the top of the high word of d2. moveq #1,d2 -> d2=%0000000000000000 00000000000000001
ror.l d2,d2 -> d2=%10000000000000000 000000000000000000
This number is NEGATIVE! because bit 31
{=ror.l #1,d2} is set! (remember: sign bit is always the highest...)

asr.l d1,d2 

Now shift 1 bit to the left because the number is negative! I don't know whether this principle
is faster than the one presented above, I just
wanted to test your bit fiddling knowledge again. So let's continue with the text...

move.w d0,d1 ;save xpos

and.w #$f,d0 ;pos in word

lsr.l d0,d2 ;shift bit pattern to this pos

lsr.w #4,d1 ;calculate word offset

add.w d1,d1

or.l d2,(a6,d1.w) ;write pattern

rts

Well, that's it for drawing everything from the point to the 15px long line at any xposition. And together with the turbo-fill routine, any horizontal line from 1-320 pixels long at any xposition can be filled at high speed.

To make this possible in many different colors, you should simply use A1/A2/A3/A4... as a plane pointer in addition to A0 and then write A ROUTINE FOR EACH COLOR! This is the only way to maintain the high speed
even with 16 colors...

68020 users have it a little easier with ShortLine:

(And that even with 32bitFillLine)

Shortline:

bfset (a6){d0:d1}

rts

So go and get yourself a decent processor....

So - that's almost done with the ProcessorVector chapter! And hopefully your style and

your knowledge has improved/expanded a little.

In terms of language, at least, we can already boast quite a lot:

Back then: I make blitter lines and then fill them...

Today: We use an integer Bresenham and a 16bit

Turbo-Fill routine to draw polygons.

Back then: That's pretty quick...

Today: We achieve a maximum efficiency of 4 pixels per

clock cycle (without cache...)

Back then: I always process a rectangle around the surface and that

with 16 colors inconvex 12 times...

Today: no point outside the surface is addressed and

every point inside is only processed once per surface, even with inconvex surfaces.

So you now have the KNOW HOW and the KNOW WHY! Now come to an agreement

with yourself about the KNOW WHEN and off you go...



SHADING
----------

Yes, we've slowly got enough tools to go deeper...
There are many types of shading with great names like:
PHONG-SHADE, GOURAUD-SHADE, FLAT-SHADE, METAL-SHADE, ENVIRONMENT-SHADE...
All of these names stand for lighting models. Each of them represents a
different compromise between speed, realism and effort.
They are all based on an algorithm that calculates the brightness of a point in space
(x, y, z) if there is a light source (lx, ly, lz) at another point in the space.
This basic algorithm can be extended to several light sources (brightness
through L1 PLUS brightness of L2 ... = total brightness of the point) and
you can also support colored light sources if you work with three brightnesses (red, green, blue) instead of one (this only makes sense with several light sources).

This algorithm is actually the angle of the light beam to the surface.

However, in order to calculate this, we first need a vector that

describes the position of the surface in space! For this, we will use a normal vector (perpendicular to the surface) that will rotate accordingly when the surface rotates.

To create the normal vector:

xa=px2-px1 (difference vector between point 1 and 2 of the surface)

ya=py2-py1

za=pz2-pz1

xb=px3-px1 (difference vector between point 1 and 3 of the surface)

yb=py3-py1

zb=pz3-pz1

xn=ya*zb-za*yb

yn=za*xb-xa*zb

zn=xa*yb-ya*xb

The creation of the difference vectors should be familiar to you from the hidden line calculation and the actual normal vector calculation is not a big hurdle either, since it is only done once at the beginning and then always rotated...

The angle is then determined using the scalar product:

S=| xn*lx+yn*ly+zn*lz |

But you're probably starting to notice that this isn't the fastest way. Above all, you need a root to determine the length of the vector. Because you have to divide the scalar product by this to get a value between 0 and 1, no matter how big the area is... So we come to simplifications that make the whole thing accessible even for non-FPU owners... The most common and probably best faked light source calculation is the one that simply divides the average of all Z coordinates of an area by a value and then interprets this as brightness... The problem here is that the value by which it is divided must be chosen so that even very close and very far away areas are treated correctly. But we don't care! Z coordinates = light source! Coders love formulas like this... (By the way, when using Z coordinates, the light source is always on the viewer's nose...) OK, you can now determine the brightness of a point, so let's continue with the shading principles...

FLAT-SHADING
------------
Is just a cool name for what people call light sourcing and describes the process in which an entire surface is filled with its average brightness...

GOURAUD-SHADING
---------------
Is the fastest shading variant! Here the brightness is determined for each corner point of a surface and all the points lying between them are interpolated accordingly. How this process is implemented will be discussed in more detail later...

METAL-SHADING
-------------
Is an extended Gouraud shading that also enables a highlight on the surface. It is calculated whether the light beam intersects the surface (falls steeply onto it) and if so this intersection point is calculated. The surface is then broken down x-----x x-x---x
| | __\ | | |
| · | / x-X---x
| | | | |
x-----x x-x---x

x=corner points ·=light beam center 
The resulting 4 surfaces are now Gouraud shaded. The newly inserted corner point (X) has an extremely bright color that the normal surface cannot otherwise reach. (e.g. light point = white area max = light blue)
This shading looks very realistic and can at first glance appear like ray tracing.

But it is also quite slow because with several light sources the surface has to be regressively divided several times.

PHONG SHADING
-------------
Was probably developed by someone who didn't have to worry about time. Because here the brightness is really calculated individually for each point on the surface. A complex process that also enables rough surfaces and bump mapping, although it is still faster than a scan line calculation.

ENVIRONMENT SHADING
-------------------
So far only used in CALIGARI and is a process for turning Phong shading into almost real ray tracing by also enabling reflections. To do this, if the reflection of a chess field in a cube is to be created, the chess field is first drawn 'from the perspective of the reflecting surface' and this image is then placed on the reflecting surface as a texture map...
Interesting but with many reflections very complicated and reductive algorithm. The process is almost always much faster than real ray tracing but almost never faster than scan line calculation.

WE SHADE OURSELVES...
---------------------
It took me some time to figure out how to program Gouraud shading, but think about it yourself first...

Task: You have a square (e.g. Salo-shaped) and you have the brightness of each corner point (they are all different because the square is completely horizontal in space) and now you want to create a surface from it, the brightness of which is set for each point in such a way that a clean transition is created between the 4 fixed values.

{ CAN YOU DO IT WITHOUT A TIP?? }

Tips: You can still build the surface from horizontal lines.

What do you need apart from the xstart and xstop values?

How can you get that?


Solution:

While we calculate the 'outline' of the surface (xstart&xstop for each line)

we also save the brightness at the beginning and end of the line.

(Or rather, we save the Z coordinate because it is more precise

than the brightness.)

We can easily calculate this because we know the brightness at the beginning and

end of a surface edge.

So when we calculate the line from point 1 to point 2, we not only save the X coordinate of this line for each line, but also the

Z coordinate. Both values ​​go into a different column in our buffer depending on whether the line is

Xstart or Xstop line.

So we need 4 entries per line:

Xstart | Zstart | Xstop | Zstop

If we have this data for each line of the surface, we can quickly draw a Gouraud shaded surface with a

slightly modified FillLine routine.

In order to get a Z coordinate for each point on the line in addition to the X coordinates, there are two possibilities:

1) We write a 3D Bresenham

2) We generate the Z coordinate by fixed point addition

I already tried option 1 - but failed and
from the looks of things, this solution would not have been particularly fast...

So we are left with number 2:

We know the Z coordinate at the beginning - we know the z coordinate at the end
and we know how many points our line will be long...

In case that is not quite clear:
The length of a line is defined in the eyes of a mathematician

(at least since Pythagoras) as follows:

l=sqr((x2-x1)²+(y2-y1)²)

Thanks to the square root, this is not a particularly attractive formula... but it cannot apply to
computer systems either, our logic tells us (yes, it does that??)..
Because a line from 0/0 to 2/2 would have a length of 2.8284271...
- that may be true on paper, but in pixels it is
completely impossible to get a non-integer value as the length because
after all, the line cannot use half or 0.82nds of a pixel...
In practice, it turns out that a line always has as many pixels as the larger delta of the line (+/- one).
So for coders, the formula is:

l=gd

Great how we have shortened that... So as much as I hate pixel stairs, they also have their advantages!

So we know the starting Z value and we know that at each point we have to add
(zend-zstart)/length
to get the next Z coordinate.
This leads us to another marginal problem: floating point numbers


THE WORLD BEHIND THE DECIMAL POINT...
------------------------------

Managing and calculating with numbers with decimal places without an FPU
is not that easy - in fact, it's even impossible.
At this point we could say: Too bad, I'll just give up....

But, yes, that's right, we don't do that because we all know that there is such a thing as
floating point numbers. If you want to store 124.78 in a form that can be understood by a computer, the floating point method stores 12478*10^-2
(more precisely, 12478 and -2 are stored).
The number is converted in such a way that all decimal places are removed,
but the number is still mathematically the same. This principle (VALUE & EXPONENT) is very flexible and very precise but
it is also very slow (!) and therefore not interesting for us...

The fixed point system is much better for us:

Every coder will come up with this system sooner or later.

What would you do to make 124.78 into a number without a decimal point??

That's right, you would multiply it by 100. The only disadvantage would be

that only numbers with a maximum of 2 decimal places could be converted into integers without loss. But the principle is clear:
To make a number into an integer, it is multiplied by a factor F

integer=real*f

So easy. To add two decimal numbers, you could proceed as follows:

1.34 + 3.66 = 5

f = 100

1.34*f = 134

3.66*f = 366

134+366 = 500

500/f = 5

So addition (and subtraction) are also possible with the self-made integers without any problems. To get the pre-decimal part of the result later, all you need to do is divide by F.

But a factor of 100 or 1000, as we humans love it, is downright disgusting for computers! So let's try it with a computer-friendly factor of f=256.

1.34*f = 343 (rounded)

3.66*f = 937 (rounded)

343+937 = 1280

1280/f = 5

So it works with any F - although we can already see here:
The smaller the factor, the less precise the result (fewer decimal places). With a factor of 256, we would have reserved 8 bits for the decimal places.

If you only want to display numbers between 0..1, you could even use 15 bits for the decimal places (f=32768) without having to leave the Word area.

But now for the first catch:

1.34*3.66 = 4.9044

f=100

134*366 = 49044

49044/f = 490.44 ! (not = 4.9044)

Surprised? No! Of course that couldn't work! So we see:
When multiplying in the fixed point system, either only one of the

two numbers (to be multiplied) can be expanded by F OR it must

then be divided by F in order not to have expanded twice by F.

An example:

1.34*3.66 = 4.9044

f=1024

1.34*f = 1372

3.66*f = 3748

1372*3748/f = 5021

5021/f = 5 (rounded)

So it works! But the inaccuracy is already noticeable here
because even with F=1024 (10bit) only 4.91... comes out instead of 5!

In practice, however, a problem will rarely arise that requires
two numbers to be multiplied by decimal places. Usually only one of the two has digits after the decimal point and in this case the following 
way is sufficient:

a=1.23 b=7

y=a*b

y*f=(a*f)*b

Ok, I think everyone has got the hang of multiplication - so let's move on...

Division is similar:

y=a/b

y*f=(a*f)/b

So here too: ONLY expand one of the numbers with F - if both have 
decimal places, one must be expanded twice y*f=(a*f*f)/(b*f)

Ok, the calculation in the world of fixed-point numbers is clear - on to
practice...

Let's say we have two INTEGER values ​​(a and b) that need to be divided.

But the result needs to be saved WITH decimal places. So:

a=a*f (extend one with f)

c=a/b (c is now a fixed point number with the result of a/b)

If this result is to be added to another number, it must also be a fixed point number, so it must also be extended with F.

Now we come to the interesting part, namely the implementation in

assembler. We want the highest possible precision, so we use

16 bits for the part after the decimal point and 16 bits for the part before the decimal point - exactly one

long word (what a coincidence)...

ATTENTION: This only works on >=68020 processors!!! Because of DIVU.L!!!!

To convert a 'normal' number into an 'extended' number, all you need is:

SWAP Dx (*65536)

CLR.w Dx (delete the decimal part (lowword))

If the highword of the 'normal' number was guaranteed to be 0, the CLR can also be omitted. An 'extended' number can also be quickly converted back into a
'normal' one:

SWAP Dx (/65536)

EXT.l Dx

Here too, the EXT can be omitted if you don't care about the high word or if
you want to convert the number back later - so to speak, temporarily store the decimal places in the high word and later (using a SWAP)
create the old fixed-point number.
If you make an effort, you only have to SWAP to change from one state to the other! But you should be extremely careful about when
where what is in the high word and what is in the low word! With so much swapping, it is easy to lose track.

An example:

(4/18)*16+0.5 = 4

V=before decimal point N=after decimal point

moveq #4,d0 ;a=4 (high=$0000 Low=$0004) 0/V

moveq #18,d1 ;b=18 (high=$0000 Low=$0012) 0/V

swap d0 ;a=4*f (high=$0004 Low=$0000) V/N 

divs.l d1,d0 ;a=a/b (high=$0000 Low=$38e3) V/N 

lsl.l #4,d0 ;a=a*16 (high=$0003 Low=$8e30) V/N
; \-only one of the numbers was expanded (a)

moveq #1,d1 ;b=1 (high=$0000 Low=$0001) 0/V
swap d1 ;b=b*f (high=$0001 Low=$0000) V/N
lsr.l #1,d1 ;b=b/2 (high=$0000 Low=$8000) V/N

add.l d1,d0 ;a=a+b (high=$0004 Low=$0e30) V/N
swap d0 ;a=a/f (high=$0e30 Low=$0004) N/V

add.w d0,d7 ;add the result to another integer number
;d7+int(a)

swap d0 ;a=a*f (high=$0004 Low=$0e30) V/N

;Continue calculating......

swap d0 ;a=a/f N/V
ext.l d0 ; 0/V

Everything clear? Well fine ! I am explaining all of this to you in such detail because later I will assume that you can juggle integers and real numbers anywhere without any problems without stumbling over a SWAP...

But it gets even better - because up until now you needed 2 SWAP commands if you (as will often happen later) only needed the part before the decimal point as an offset, for example:

d0 - is an extended counter

d1 - is an extended number

Loop:

add.l d1,d0 ;count up

swap d0 ;make an integer

move.w (a0,d0.w),d7 ;use as offset (only the lower word!!!)

swap d0 ;back to the old real number...

We will find this type of memory addressing with real numbers on all

possible occasions! So here is another optimization, which requires even more brainpower:

First the idea:
It would be much more useful if, instead of the old division: HIGHword=predec.

and LOWword=postdec., you could manage to keep the numbers in memory like this: HIGHword=postdec. LOWword=predec. ! (exactly the other way around).

After the example above, it is obvious why this is an advantage:
with a '(a0,d0.w)', the part before the decimal point can be addressed directly

without having to swap first.

But this type of number cannot be added so easily, because if
the part after the decimal point (highwords) 'overflows', the part before the decimal point (lowword) is not automatically increased by 1ns, as was the case with the old division. But here a trick helps:

moveq #0,d7 ;dummy register that must be set to zero!

in d0 there is a counter in the new system (N/V)

in d1 there is a number in the new system (N/V)

add.l d1,d0 ;Addition with fixed point numbers in the N/V system.

addx.w d7,d0 

Well, that looks cool, doesn't it? I was pretty proud of this idea back then - until I noticed that many people had had it before me - but whatever.

So we carry out a normal addition and if the high word had an overflow (decimal part) then ADD automatically sets the X-FLAG! (see bit-fiddling tricks).

The next command (ADDX.w) now adds D7 to D0 - which is pretty ineffective because D7 is always at 0; pointless then? No, because AddX also checks the X-flag and, if it is set, adds an additional 1 to D0! This means that if the part after the decimal point overflows (0.9999+0.1), the part before the decimal point (in the low word) is automatically increased by one. After ADDX, the X-flag is deleted again and the loop can be run through again.... We have therefore added two fixed-point numbers with a part before the decimal point in the LOW word with just two commands. This effectively means that one command has been saved compared to the swap/add/swap method - not much? Maybe, but that is the stuff that records are made of! Subtraction works accordingly: sub.l d1,d0 subx.w d7,d0 Only multiplications and divisions are NOT possible in this system!! To do this, you have to switch back to the 'old' V/N system using a SWAP. After the calculation, you then continue in the N/V system using SWAP...

To add d1 and then divide by d2 in a loop:

add.l d1,d0 ;N/V addition

addx.w d7,d0

swap d0 ;make V/N

divu.l d2,d0 ;V/N division

swap d0 ;make N/V

.

.

I think you're starting to get an idea of ​​how confusing a swap can be...

It gets even more confusing if you want to perform multiplications in the N/V system by

shifting - this is possible if you use

rol.l #4,d0 ;n/v *16 instead of

lsl.w #4,d0 ;normal *16

command is used. This is necessary so that the bits from the part after the decimal point are correctly transferred to the part before the decimal point. ATTENTION: If the values ​​are too large, an overflow occurs in the low word and very large values ​​become very small... (this error also occurs with INTEGER values). Division is also possible with shifting - but it is faster if you switch to V/N with two short swaps. In N/V mode, an AND would be necessary to eliminate bits shifted from the HIGH to the LOW word. ror.l #x,d0 ; divide n/v and.l #$ffff0000+($ffff>>x),d0 ; correct And there is a normal... swap d0 lsr.l #x,d0 swap d0... much more convenient and faster too! SO! That's enough for today - enough learning and enough chattering...
Tomorrow is another day (I hope?!) and then I'll continue with my
NICE and ONLY WORKSHOP... [03:27:07]
I hope you're not dreaming of bits....

{Dream, snore, grin....}







SCIENTS FICTION
---------------

Where is the development going? I believe that a computer will soon be
structured as follows...
CONSUMER VERSION

2-4 RISC CPUs with 100mhz, all of which have a parallel FPU section

and can exchange data with each other without

having to go through the memory...

Each of the CPUs has an 8mb on-chip cache that stores the entire

currently running program and is connected to the memory with a pipeline.

Multitasking would therefore be 1) program in cache 2) next program in

pipeline 3) while P1 is being processed 4) task switch (pipeline->cache)

5) next program in, pipeline.....

and that on 2-4 processors at the same time!!

The main memory should be around 128 MB and, like the CPUs, work with a bandwidth of 64 bits. All CPUs can read the same address at the same time! Only when a write access to an address occurs is it locked for a short time. A video chip could generate the image from a 32-bit chunky mode (one long word per pixel). The lower 24 bits are used as color data and the upper 8 bits as an alpha channel. The video chip can generate resolutions of up to 2048x2048 without falling below a frequency of 70 Hz. The video chip is of course able to address the system memory directly - so you don't need a BUS like on PC systems. For the sound output, 12 voices with 16-bit quality would probably be sufficient, although an asynchronous sound chip (like in the Amiga) will of course be used so that you don't have to shovel the samples around yourself. A 64-bit parallel connection would be very useful in order to handle the amount of data that is generated by data gloves/video cameras. This would have to be connected to the main memory via a small 1MB buffer. The only media that would be possible would actually be rewritable CDs or similar... DAT recorders (several gigabytes per tape) could also become affordable... But neither the computing power nor the speed will ever be sufficient... With the 4RISC CPU/FPUs, around 50hz real-time ray tracing (at 50,000 polygons) in the 24-bit chunky would be possible at 100mhz - but 50hz is then no longer 1 frame... And coding will not be child's play here either, because 2048x2048 long words have to be calculated first (13422000000000 bits compared to the 655360 bits we work with today...) so: hardcore coders will always be needed and games in Basic will NEVER be a hit... Even if Cities can be explored in Basic 1frame (70hz) texture mapping
- who wants that when you can fly through scanline cities with
shadows, fog, reflections etc. in assembler...
